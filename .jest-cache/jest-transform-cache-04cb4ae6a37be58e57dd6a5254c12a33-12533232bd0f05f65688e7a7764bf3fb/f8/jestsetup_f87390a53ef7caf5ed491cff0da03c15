c9998c4c4c375a52c415f9309710899c
// Learn more: https://github.com/testing-library/jest-dom
"use strict";
// Mock Next.js router
jest.mock('next/navigation', ()=>({
        useRouter () {
            return {
                push: jest.fn(),
                replace: jest.fn(),
                prefetch: jest.fn(),
                back: jest.fn(),
                pathname: '/',
                query: {},
                asPath: '/'
            };
        },
        useSearchParams () {
            return new URLSearchParams();
        },
        usePathname () {
            return '/';
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("@testing-library/jest-dom");
// Ensure window exists
if (typeof window === 'undefined') {
    global.window = {};
}
// Mock localStorage with a working store that persists across tests
// This will be overridden by individual test files, but provides a fallback
let localStorageStore = {};
const localStorageMock = {
    getItem: jest.fn((key)=>{
        return localStorageStore[key] || null;
    }),
    setItem: jest.fn((key, value)=>{
        localStorageStore[key] = value.toString();
    }),
    removeItem: jest.fn((key)=>{
        delete localStorageStore[key];
    }),
    clear: jest.fn(()=>{
        localStorageStore = {};
    })
};
// Set up localStorage on window and as a global
// This ensures localStorage is available as a global variable (not just window.localStorage)
Object.defineProperty(window, 'localStorage', {
    value: localStorageMock,
    writable: true,
    configurable: true
});
// Make localStorage available as a global (browser behavior)
Object.defineProperty(global, 'localStorage', {
    value: localStorageMock,
    writable: true,
    configurable: true
});
// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: jest.fn().mockImplementation((query)=>({
            matches: false,
            media: query,
            onchange: null,
            addListener: jest.fn(),
            removeListener: jest.fn(),
            addEventListener: jest.fn(),
            removeEventListener: jest.fn(),
            dispatchEvent: jest.fn()
        }))
});
// Polyfill TextEncoder/TextDecoder for Node.js environment
if (typeof TextEncoder === 'undefined') {
    const { TextEncoder: TextEncoder1, TextDecoder } = require('util');
    global.TextEncoder = TextEncoder1;
    global.TextDecoder = TextDecoder;
}
// Mock crypto.subtle for password security tests
// Store hashes by salt to ensure consistent verification
const cryptoHashStore = new Map();
// Always set up crypto mock for tests
global.crypto = {
    getRandomValues: (arr)=>{
        // Return predictable values for testing (based on array length for consistency)
        for(let i = 0; i < arr.length; i++){
            arr[i] = i * 17 % 256; // Use prime number for better distribution
        }
        return arr;
    },
    subtle: {
        importKey: jest.fn().mockImplementation(async ()=>{
            return {
                format: 'raw',
                algorithm: {
                    name: 'PBKDF2'
                },
                extractable: false,
                keyUsages: [
                    'deriveBits'
                ]
            };
        }),
        deriveBits: jest.fn().mockImplementation(async (algorithm, keyMaterial, length)=>{
            // Create a consistent hash based on salt
            const saltHex = Array.from(algorithm.salt).map((b)=>b.toString(16).padStart(2, '0')).join('');
            const key = `${saltHex}-${length}`;
            if (!cryptoHashStore.has(key)) {
                // Generate a predictable hash based on salt
                const hash = new Uint8Array(length / 8);
                for(let i = 0; i < hash.length; i++){
                    hash[i] = (i * 7 + saltHex.charCodeAt(i % saltHex.length)) % 256;
                }
                cryptoHashStore.set(key, hash.buffer);
            }
            return cryptoHashStore.get(key);
        })
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxUZWNoIFZpdHRhXFxBcHBzXFxERU1PXFxqZXN0LnNldHVwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExlYXJuIG1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZXN0aW5nLWxpYnJhcnkvamVzdC1kb21cclxuaW1wb3J0ICdAdGVzdGluZy1saWJyYXJ5L2plc3QtZG9tJ1xyXG5cclxuLy8gTW9jayBOZXh0LmpzIHJvdXRlclxyXG5qZXN0Lm1vY2soJ25leHQvbmF2aWdhdGlvbicsICgpID0+ICh7XHJcbiAgdXNlUm91dGVyKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHVzaDogamVzdC5mbigpLFxyXG4gICAgICByZXBsYWNlOiBqZXN0LmZuKCksXHJcbiAgICAgIHByZWZldGNoOiBqZXN0LmZuKCksXHJcbiAgICAgIGJhY2s6IGplc3QuZm4oKSxcclxuICAgICAgcGF0aG5hbWU6ICcvJyxcclxuICAgICAgcXVlcnk6IHt9LFxyXG4gICAgICBhc1BhdGg6ICcvJyxcclxuICAgIH1cclxuICB9LFxyXG4gIHVzZVNlYXJjaFBhcmFtcygpIHtcclxuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKClcclxuICB9LFxyXG4gIHVzZVBhdGhuYW1lKCkge1xyXG4gICAgcmV0dXJuICcvJ1xyXG4gIH0sXHJcbn0pKVxyXG5cclxuLy8gRW5zdXJlIHdpbmRvdyBleGlzdHNcclxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgZ2xvYmFsLndpbmRvdyA9IHt9O1xyXG59XHJcblxyXG4vLyBNb2NrIGxvY2FsU3RvcmFnZSB3aXRoIGEgd29ya2luZyBzdG9yZSB0aGF0IHBlcnNpc3RzIGFjcm9zcyB0ZXN0c1xyXG4vLyBUaGlzIHdpbGwgYmUgb3ZlcnJpZGRlbiBieSBpbmRpdmlkdWFsIHRlc3QgZmlsZXMsIGJ1dCBwcm92aWRlcyBhIGZhbGxiYWNrXHJcbmxldCBsb2NhbFN0b3JhZ2VTdG9yZSA9IHt9O1xyXG5jb25zdCBsb2NhbFN0b3JhZ2VNb2NrID0ge1xyXG4gIGdldEl0ZW06IGplc3QuZm4oKGtleSkgPT4ge1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZVN0b3JlW2tleV0gfHwgbnVsbDtcclxuICB9KSxcclxuICBzZXRJdGVtOiBqZXN0LmZuKChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICBsb2NhbFN0b3JhZ2VTdG9yZVtrZXldID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICB9KSxcclxuICByZW1vdmVJdGVtOiBqZXN0LmZuKChrZXkpID0+IHtcclxuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VTdG9yZVtrZXldO1xyXG4gIH0pLFxyXG4gIGNsZWFyOiBqZXN0LmZuKCgpID0+IHtcclxuICAgIGxvY2FsU3RvcmFnZVN0b3JlID0ge307XHJcbiAgfSksXHJcbn07XHJcblxyXG4vLyBTZXQgdXAgbG9jYWxTdG9yYWdlIG9uIHdpbmRvdyBhbmQgYXMgYSBnbG9iYWxcclxuLy8gVGhpcyBlbnN1cmVzIGxvY2FsU3RvcmFnZSBpcyBhdmFpbGFibGUgYXMgYSBnbG9iYWwgdmFyaWFibGUgKG5vdCBqdXN0IHdpbmRvdy5sb2NhbFN0b3JhZ2UpXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdsb2NhbFN0b3JhZ2UnLCB7XHJcbiAgdmFsdWU6IGxvY2FsU3RvcmFnZU1vY2ssXHJcbiAgd3JpdGFibGU6IHRydWUsXHJcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG59KTtcclxuXHJcbi8vIE1ha2UgbG9jYWxTdG9yYWdlIGF2YWlsYWJsZSBhcyBhIGdsb2JhbCAoYnJvd3NlciBiZWhhdmlvcilcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbCwgJ2xvY2FsU3RvcmFnZScsIHtcclxuICB2YWx1ZTogbG9jYWxTdG9yYWdlTW9jayxcclxuICB3cml0YWJsZTogdHJ1ZSxcclxuICBjb25maWd1cmFibGU6IHRydWUsXHJcbn0pO1xyXG5cclxuLy8gTW9jayB3aW5kb3cubWF0Y2hNZWRpYVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnbWF0Y2hNZWRpYScsIHtcclxuICB3cml0YWJsZTogdHJ1ZSxcclxuICB2YWx1ZTogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbihxdWVyeSA9PiAoe1xyXG4gICAgbWF0Y2hlczogZmFsc2UsXHJcbiAgICBtZWRpYTogcXVlcnksXHJcbiAgICBvbmNoYW5nZTogbnVsbCxcclxuICAgIGFkZExpc3RlbmVyOiBqZXN0LmZuKCksXHJcbiAgICByZW1vdmVMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogamVzdC5mbigpLFxyXG4gICAgZGlzcGF0Y2hFdmVudDogamVzdC5mbigpLFxyXG4gIH0pKSxcclxufSlcclxuXHJcbi8vIFBvbHlmaWxsIFRleHRFbmNvZGVyL1RleHREZWNvZGVyIGZvciBOb2RlLmpzIGVudmlyb25tZW50XHJcbmlmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgY29uc3QgeyBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcclxuICBnbG9iYWwuVGV4dEVuY29kZXIgPSBUZXh0RW5jb2RlcjtcclxuICBnbG9iYWwuVGV4dERlY29kZXIgPSBUZXh0RGVjb2RlcjtcclxufVxyXG5cclxuLy8gTW9jayBjcnlwdG8uc3VidGxlIGZvciBwYXNzd29yZCBzZWN1cml0eSB0ZXN0c1xyXG4vLyBTdG9yZSBoYXNoZXMgYnkgc2FsdCB0byBlbnN1cmUgY29uc2lzdGVudCB2ZXJpZmljYXRpb25cclxuY29uc3QgY3J5cHRvSGFzaFN0b3JlID0gbmV3IE1hcCgpO1xyXG5cclxuLy8gQWx3YXlzIHNldCB1cCBjcnlwdG8gbW9jayBmb3IgdGVzdHNcclxuZ2xvYmFsLmNyeXB0byA9IHtcclxuICBnZXRSYW5kb21WYWx1ZXM6IChhcnIpID0+IHtcclxuICAgIC8vIFJldHVybiBwcmVkaWN0YWJsZSB2YWx1ZXMgZm9yIHRlc3RpbmcgKGJhc2VkIG9uIGFycmF5IGxlbmd0aCBmb3IgY29uc2lzdGVuY3kpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhcnJbaV0gPSAoaSAqIDE3KSAlIDI1NjsgLy8gVXNlIHByaW1lIG51bWJlciBmb3IgYmV0dGVyIGRpc3RyaWJ1dGlvblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycjtcclxuICB9LFxyXG4gIHN1YnRsZToge1xyXG4gICAgaW1wb3J0S2V5OiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcclxuICAgICAgcmV0dXJuIHsgZm9ybWF0OiAncmF3JywgYWxnb3JpdGhtOiB7IG5hbWU6ICdQQktERjInIH0sIGV4dHJhY3RhYmxlOiBmYWxzZSwga2V5VXNhZ2VzOiBbJ2Rlcml2ZUJpdHMnXSB9O1xyXG4gICAgfSksXHJcbiAgICBkZXJpdmVCaXRzOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChhbGdvcml0aG0sIGtleU1hdGVyaWFsLCBsZW5ndGgpID0+IHtcclxuICAgICAgLy8gQ3JlYXRlIGEgY29uc2lzdGVudCBoYXNoIGJhc2VkIG9uIHNhbHRcclxuICAgICAgY29uc3Qgc2FsdEhleCA9IEFycmF5LmZyb20oYWxnb3JpdGhtLnNhbHQpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xyXG4gICAgICBjb25zdCBrZXkgPSBgJHtzYWx0SGV4fS0ke2xlbmd0aH1gO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFjcnlwdG9IYXNoU3RvcmUuaGFzKGtleSkpIHtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBhIHByZWRpY3RhYmxlIGhhc2ggYmFzZWQgb24gc2FsdFxyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZXcgVWludDhBcnJheShsZW5ndGggLyA4KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhc2gubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGhhc2hbaV0gPSAoaSAqIDcgKyBzYWx0SGV4LmNoYXJDb2RlQXQoaSAlIHNhbHRIZXgubGVuZ3RoKSkgJSAyNTY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNyeXB0b0hhc2hTdG9yZS5zZXQoa2V5LCBoYXNoLmJ1ZmZlcik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBjcnlwdG9IYXNoU3RvcmUuZ2V0KGtleSk7XHJcbiAgICB9KVxyXG4gIH1cclxufTtcclxuXHJcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVJvdXRlciIsInB1c2giLCJmbiIsInJlcGxhY2UiLCJwcmVmZXRjaCIsImJhY2siLCJwYXRobmFtZSIsInF1ZXJ5IiwiYXNQYXRoIiwidXNlU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidXNlUGF0aG5hbWUiLCJ3aW5kb3ciLCJnbG9iYWwiLCJsb2NhbFN0b3JhZ2VTdG9yZSIsImxvY2FsU3RvcmFnZU1vY2siLCJnZXRJdGVtIiwia2V5Iiwic2V0SXRlbSIsInZhbHVlIiwidG9TdHJpbmciLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwibWF0Y2hlcyIsIm1lZGlhIiwib25jaGFuZ2UiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50IiwiVGV4dEVuY29kZXIiLCJUZXh0RGVjb2RlciIsInJlcXVpcmUiLCJjcnlwdG9IYXNoU3RvcmUiLCJNYXAiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJhcnIiLCJpIiwibGVuZ3RoIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiZm9ybWF0IiwiYWxnb3JpdGhtIiwibmFtZSIsImV4dHJhY3RhYmxlIiwia2V5VXNhZ2VzIiwiZGVyaXZlQml0cyIsImtleU1hdGVyaWFsIiwic2FsdEhleCIsIkFycmF5IiwiZnJvbSIsInNhbHQiLCJtYXAiLCJiIiwicGFkU3RhcnQiLCJqb2luIiwiaGFzIiwiaGFzaCIsIlVpbnQ4QXJyYXkiLCJjaGFyQ29kZUF0Iiwic2V0IiwiYnVmZmVyIiwiZ2V0Il0sIm1hcHBpbmdzIjoiQUFBQSwwREFBMEQ7O0FBRzFELHNCQUFzQjtBQUN0QkEsS0FBS0MsSUFBSSxDQUFDLG1CQUFtQixJQUFPLENBQUE7UUFDbENDO1lBQ0UsT0FBTztnQkFDTEMsTUFBTUgsS0FBS0ksRUFBRTtnQkFDYkMsU0FBU0wsS0FBS0ksRUFBRTtnQkFDaEJFLFVBQVVOLEtBQUtJLEVBQUU7Z0JBQ2pCRyxNQUFNUCxLQUFLSSxFQUFFO2dCQUNiSSxVQUFVO2dCQUNWQyxPQUFPLENBQUM7Z0JBQ1JDLFFBQVE7WUFDVjtRQUNGO1FBQ0FDO1lBQ0UsT0FBTyxJQUFJQztRQUNiO1FBQ0FDO1lBQ0UsT0FBTztRQUNUO0lBQ0YsQ0FBQTs7OztRQXJCTztBQXVCUCx1QkFBdUI7QUFDdkIsSUFBSSxPQUFPQyxXQUFXLGFBQWE7SUFDakNDLE9BQU9ELE1BQU0sR0FBRyxDQUFDO0FBQ25CO0FBRUEsb0VBQW9FO0FBQ3BFLDRFQUE0RTtBQUM1RSxJQUFJRSxvQkFBb0IsQ0FBQztBQUN6QixNQUFNQyxtQkFBbUI7SUFDdkJDLFNBQVNsQixLQUFLSSxFQUFFLENBQUMsQ0FBQ2U7UUFDaEIsT0FBT0gsaUJBQWlCLENBQUNHLElBQUksSUFBSTtJQUNuQztJQUNBQyxTQUFTcEIsS0FBS0ksRUFBRSxDQUFDLENBQUNlLEtBQUtFO1FBQ3JCTCxpQkFBaUIsQ0FBQ0csSUFBSSxHQUFHRSxNQUFNQyxRQUFRO0lBQ3pDO0lBQ0FDLFlBQVl2QixLQUFLSSxFQUFFLENBQUMsQ0FBQ2U7UUFDbkIsT0FBT0gsaUJBQWlCLENBQUNHLElBQUk7SUFDL0I7SUFDQUssT0FBT3hCLEtBQUtJLEVBQUUsQ0FBQztRQUNiWSxvQkFBb0Is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