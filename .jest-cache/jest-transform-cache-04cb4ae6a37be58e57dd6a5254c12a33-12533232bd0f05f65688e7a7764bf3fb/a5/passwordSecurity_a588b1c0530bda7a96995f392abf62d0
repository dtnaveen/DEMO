819e0a57d78fe3bd6bf06c6f10a7784f
/**
 * Password Security Utilities
 * Implements secure password hashing and verification using Web Crypto API
 * Production-ready security implementation
 */ /**
 * Hash a password using Web Crypto API (PBKDF2)
 * @param {string} password - Plain text password
 * @returns {Promise<string>} Hashed password with salt
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get hashPassword () {
        return hashPassword;
    },
    get isSecureHash () {
        return isSecureHash;
    },
    get loginRateLimiter () {
        return loginRateLimiter;
    },
    get validatePasswordStrength () {
        return validatePasswordStrength;
    },
    get verifyPassword () {
        return verifyPassword;
    }
});
async function hashPassword(password) {
    if (!password || typeof password !== 'string') {
        throw new Error('Password must be a non-empty string');
    }
    // Generate a random salt
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const saltHex = Array.from(salt).map((b)=>b.toString(16).padStart(2, '0')).join('');
    // Import password as key material
    const encoder = new TextEncoder();
    const passwordData = encoder.encode(password);
    // Use PBKDF2 for key derivation (100,000 iterations for security)
    const keyMaterial = await crypto.subtle.importKey('raw', passwordData, {
        name: 'PBKDF2'
    }, false, [
        'deriveBits'
    ]);
    const derivedBits = await crypto.subtle.deriveBits({
        name: 'PBKDF2',
        salt: salt,
        iterations: 100000,
        hash: 'SHA-256'
    }, keyMaterial, 256 // 32 bytes = 256 bits
    );
    // Convert to hex string
    const hashArray = Array.from(new Uint8Array(derivedBits));
    const hashHex = hashArray.map((b)=>b.toString(16).padStart(2, '0')).join('');
    // Return format: salt:hash (both hex)
    return `${saltHex}:${hashHex}`;
}
async function verifyPassword(password, hash) {
    if (!password || !hash) {
        return false;
    }
    // Backward compatibility: if hash doesn't contain ':', it's plain text (old format)
    // This allows existing test users to still log in, then their password will be migrated
    if (!hash.includes(':')) {
        // Plain text comparison for backward compatibility
        return password === hash;
    }
    try {
        // Extract salt and hash from stored format
        const [saltHex, storedHash] = hash.split(':');
        if (!saltHex || !storedHash) {
            return false;
        }
        // Convert salt from hex to Uint8Array
        const salt = new Uint8Array(saltHex.match(/.{1,2}/g).map((byte)=>parseInt(byte, 16)));
        // Import password as key material
        const encoder = new TextEncoder();
        const passwordData = encoder.encode(password);
        const keyMaterial = await crypto.subtle.importKey('raw', passwordData, {
            name: 'PBKDF2'
        }, false, [
            'deriveBits'
        ]);
        // Derive hash with same parameters
        const derivedBits = await crypto.subtle.deriveBits({
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        }, keyMaterial, 256);
        // Convert to hex
        const hashArray = Array.from(new Uint8Array(derivedBits));
        const hashHex = hashArray.map((b)=>b.toString(16).padStart(2, '0')).join('');
        // Compare hashes (constant-time comparison)
        return hashHex === storedHash;
    } catch (error) {
        console.error('Error verifying password:', error);
        return false;
    }
}
function isSecureHash(hash) {
    if (!hash || typeof hash !== 'string') {
        return false;
    }
    const parts = hash.split(':');
    return parts.length === 2 && parts[0].length > 0 && parts[1].length > 0;
}
function validatePasswordStrength(password) {
    if (!password) {
        return {
            isValid: false,
            message: 'Password is required'
        };
    }
    if (password.length < 8) {
        return {
            isValid: false,
            message: 'Password must be at least 8 characters'
        };
    }
    if (password.length > 128) {
        return {
            isValid: false,
            message: 'Password must be less than 128 characters'
        };
    }
    // Check for at least one number
    if (!/\d/.test(password)) {
        return {
            isValid: false,
            message: 'Password must contain at least one number'
        };
    }
    // Check for at least one letter
    if (!/[a-zA-Z]/.test(password)) {
        return {
            isValid: false,
            message: 'Password must contain at least one letter'
        };
    }
    return {
        isValid: true,
        message: 'Password is strong'
    };
}
/**
 * Rate limiting for login attempts
 */ class LoginRateLimiter {
    constructor(){
        this.attempts = new Map(); // identifier -> { count, resetTime }
        this.maxAttempts = 5; // Maximum attempts
        this.lockoutDuration = 15 * 60 * 1000; // 15 minutes in milliseconds
    }
    /**
   * Record a failed login attempt
   * @param {string} identifier - Email or username
   */ recordFailedAttempt(identifier) {
        if (typeof window === 'undefined') return;
        const key = identifier.toLowerCase();
        const now = Date.now();
        const record = this.attempts.get(key) || {
            count: 0,
            resetTime: now + this.lockoutDuration
        };
        // Reset if lockout period has passed
        if (now > record.resetTime) {
            record.count = 0;
            record.resetTime = now + this.lockoutDuration;
        }
        record.count++;
        this.attempts.set(key, record);
        // Persist to localStorage
        try {
            const attemptsData = {};
            this.attempts.forEach((value, key)=>{
                attemptsData[key] = value;
            });
            localStorage.setItem('login_attempts', JSON.stringify(attemptsData));
        } catch (error) {
            console.error('Error saving login attempts:', error);
        }
    }
    /**
   * Clear failed attempts for an identifier (on successful login)
   * @param {string} identifier - Email or username
   */ clearAttempts(identifier) {
        if (typeof window === 'undefined') return;
        const key = identifier.toLowerCase();
        this.attempts.delete(key);
        // Update localStorage
        try {
            const attemptsData = JSON.parse(localStorage.getItem('login_attempts') || '{}');
            delete attemptsData[key];
            localStorage.setItem('login_attempts', JSON.stringify(attemptsData));
        } catch (error) {
            console.error('Error clearing login attempts:', error);
        }
    }
    /**
   * Check if identifier is rate limited
   * @param {string} identifier - Email or username
   * @returns {Object} { isLimited: boolean, remainingTime: number (ms), attemptsLeft: number }
   */ isRateLimited(identifier) {
        if (typeof window === 'undefined') {
            return {
                isLimited: false,
                remainingTime: 0,
                attemptsLeft: this.maxAttempts
            };
        }
        // Load from localStorage
        try {
            const attemptsData = JSON.parse(localStorage.getItem('login_attempts') || '{}');
            this.attempts.clear();
            Object.entries(attemptsData).forEach(([key, value])=>{
                this.attempts.set(key, value);
            });
        } catch (error) {
        // Ignore errors
        }
        const key = identifier.toLowerCase();
        const record = this.attempts.get(key);
        if (!record) {
            return {
                isLimited: false,
                remainingTime: 0,
                attemptsLeft: this.maxAttempts
            };
        }
        const now = Date.now();
        // Reset if lockout period has passed
        if (now > record.resetTime) {
            this.attempts.delete(key);
            return {
                isLimited: false,
                remainingTime: 0,
                attemptsLeft: this.maxAttempts
            };
        }
        const attemptsLeft = Math.max(0, this.maxAttempts - record.count);
        const isLimited = record.count >= this.maxAttempts;
        const remainingTime = Math.max(0, record.resetTime - now);
        return {
            isLimited,
            remainingTime,
            attemptsLeft
        };
    }
}
const loginRateLimiter = new LoginRateLimiter();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxUZWNoIFZpdHRhXFxBcHBzXFxERU1PXFxsaWJcXHBhc3N3b3JkU2VjdXJpdHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFBhc3N3b3JkIFNlY3VyaXR5IFV0aWxpdGllc1xyXG4gKiBJbXBsZW1lbnRzIHNlY3VyZSBwYXNzd29yZCBoYXNoaW5nIGFuZCB2ZXJpZmljYXRpb24gdXNpbmcgV2ViIENyeXB0byBBUElcclxuICogUHJvZHVjdGlvbi1yZWFkeSBzZWN1cml0eSBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBIYXNoIGEgcGFzc3dvcmQgdXNpbmcgV2ViIENyeXB0byBBUEkgKFBCS0RGMilcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gUGxhaW4gdGV4dCBwYXNzd29yZFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBIYXNoZWQgcGFzc3dvcmQgd2l0aCBzYWx0XHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFzaFBhc3N3b3JkKHBhc3N3b3JkKSB7XHJcbiAgaWYgKCFwYXNzd29yZCB8fCB0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XHJcbiAgfVxyXG5cclxuICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBzYWx0XHJcbiAgY29uc3Qgc2FsdCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTtcclxuICBjb25zdCBzYWx0SGV4ID0gQXJyYXkuZnJvbShzYWx0KS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcclxuXHJcbiAgLy8gSW1wb3J0IHBhc3N3b3JkIGFzIGtleSBtYXRlcmlhbFxyXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuICBjb25zdCBwYXNzd29yZERhdGEgPSBlbmNvZGVyLmVuY29kZShwYXNzd29yZCk7XHJcblxyXG4gIC8vIFVzZSBQQktERjIgZm9yIGtleSBkZXJpdmF0aW9uICgxMDAsMDAwIGl0ZXJhdGlvbnMgZm9yIHNlY3VyaXR5KVxyXG4gIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXHJcbiAgICAncmF3JyxcclxuICAgIHBhc3N3b3JkRGF0YSxcclxuICAgIHsgbmFtZTogJ1BCS0RGMicgfSxcclxuICAgIGZhbHNlLFxyXG4gICAgWydkZXJpdmVCaXRzJ11cclxuICApO1xyXG5cclxuICBjb25zdCBkZXJpdmVkQml0cyA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhcclxuICAgIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgIHNhbHQ6IHNhbHQsXHJcbiAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwMCxcclxuICAgICAgaGFzaDogJ1NIQS0yNTYnXHJcbiAgICB9LFxyXG4gICAga2V5TWF0ZXJpYWwsXHJcbiAgICAyNTYgLy8gMzIgYnl0ZXMgPSAyNTYgYml0c1xyXG4gICk7XHJcblxyXG4gIC8vIENvbnZlcnQgdG8gaGV4IHN0cmluZ1xyXG4gIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoZGVyaXZlZEJpdHMpKTtcclxuICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xyXG5cclxuICAvLyBSZXR1cm4gZm9ybWF0OiBzYWx0Omhhc2ggKGJvdGggaGV4KVxyXG4gIHJldHVybiBgJHtzYWx0SGV4fToke2hhc2hIZXh9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZlcmlmeSBhIHBhc3N3b3JkIGFnYWluc3QgYSBoYXNoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFBsYWluIHRleHQgcGFzc3dvcmQgdG8gdmVyaWZ5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gU3RvcmVkIGhhc2ggKGZvcm1hdDogc2FsdDpoYXNoIG9yIHBsYWluIHRleHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIHBhc3N3b3JkIG1hdGNoZXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlQYXNzd29yZChwYXNzd29yZCwgaGFzaCkge1xyXG4gIGlmICghcGFzc3dvcmQgfHwgIWhhc2gpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGlmIGhhc2ggZG9lc24ndCBjb250YWluICc6JywgaXQncyBwbGFpbiB0ZXh0IChvbGQgZm9ybWF0KVxyXG4gIC8vIFRoaXMgYWxsb3dzIGV4aXN0aW5nIHRlc3QgdXNlcnMgdG8gc3RpbGwgbG9nIGluLCB0aGVuIHRoZWlyIHBhc3N3b3JkIHdpbGwgYmUgbWlncmF0ZWRcclxuICBpZiAoIWhhc2guaW5jbHVkZXMoJzonKSkge1xyXG4gICAgLy8gUGxhaW4gdGV4dCBjb21wYXJpc29uIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbiAgICByZXR1cm4gcGFzc3dvcmQgPT09IGhhc2g7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRXh0cmFjdCBzYWx0IGFuZCBoYXNoIGZyb20gc3RvcmVkIGZvcm1hdFxyXG4gICAgY29uc3QgW3NhbHRIZXgsIHN0b3JlZEhhc2hdID0gaGFzaC5zcGxpdCgnOicpO1xyXG4gICAgaWYgKCFzYWx0SGV4IHx8ICFzdG9yZWRIYXNoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb252ZXJ0IHNhbHQgZnJvbSBoZXggdG8gVWludDhBcnJheVxyXG4gICAgY29uc3Qgc2FsdCA9IG5ldyBVaW50OEFycmF5KFxyXG4gICAgICBzYWx0SGV4Lm1hdGNoKC8uezEsMn0vZykubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBJbXBvcnQgcGFzc3dvcmQgYXMga2V5IG1hdGVyaWFsXHJcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgICBjb25zdCBwYXNzd29yZERhdGEgPSBlbmNvZGVyLmVuY29kZShwYXNzd29yZCk7XHJcblxyXG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcclxuICAgICAgJ3JhdycsXHJcbiAgICAgIHBhc3N3b3JkRGF0YSxcclxuICAgICAgeyBuYW1lOiAnUEJLREYyJyB9LFxyXG4gICAgICBmYWxzZSxcclxuICAgICAgWydkZXJpdmVCaXRzJ11cclxuICAgICk7XHJcblxyXG4gICAgLy8gRGVyaXZlIGhhc2ggd2l0aCBzYW1lIHBhcmFtZXRlcnNcclxuICAgIGNvbnN0IGRlcml2ZWRCaXRzID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZXJpdmVCaXRzKFxyXG4gICAgICB7XHJcbiAgICAgICAgbmFtZTogJ1BCS0RGMicsXHJcbiAgICAgICAgc2FsdDogc2FsdCxcclxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDAsXHJcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnXHJcbiAgICAgIH0sXHJcbiAgICAgIGtleU1hdGVyaWFsLFxyXG4gICAgICAyNTZcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ29udmVydCB0byBoZXhcclxuICAgIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoZGVyaXZlZEJpdHMpKTtcclxuICAgIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBoYXNoZXMgKGNvbnN0YW50LXRpbWUgY29tcGFyaXNvbilcclxuICAgIHJldHVybiBoYXNoSGV4ID09PSBzdG9yZWRIYXNoO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgcGFzc3dvcmQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgcGFzc3dvcmQgaGFzaCBpcyBpbiB0aGUgbmV3IHNlY3VyZSBmb3JtYXRcclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggLSBQYXNzd29yZCBoYXNoIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGhhc2ggaXMgaW4gc2VjdXJlIGZvcm1hdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VjdXJlSGFzaChoYXNoKSB7XHJcbiAgaWYgKCFoYXNoIHx8IHR5cGVvZiBoYXNoICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCBwYXJ0cyA9IGhhc2guc3BsaXQoJzonKTtcclxuICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAyICYmIHBhcnRzWzBdLmxlbmd0aCA+IDAgJiYgcGFydHNbMV0ubGVuZ3RoID4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHBhc3N3b3JkIHN0cmVuZ3RoXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFBhc3N3b3JkIHRvIHZhbGlkYXRlXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFZhbGlkYXRpb24gcmVzdWx0IHdpdGggaXNWYWxpZCBhbmQgbWVzc2FnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aChwYXNzd29yZCkge1xyXG4gIGlmICghcGFzc3dvcmQpIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnUGFzc3dvcmQgaXMgcmVxdWlyZWQnIH07XHJcbiAgfVxyXG5cclxuICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgOCkge1xyXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycycgfTtcclxuICB9XHJcblxyXG4gIGlmIChwYXNzd29yZC5sZW5ndGggPiAxMjgpIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnUGFzc3dvcmQgbXVzdCBiZSBsZXNzIHRoYW4gMTI4IGNoYXJhY3RlcnMnIH07XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBmb3IgYXQgbGVhc3Qgb25lIG51bWJlclxyXG4gIGlmICghL1xcZC8udGVzdChwYXNzd29yZCkpIHtcclxuICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCBtZXNzYWdlOiAnUGFzc3dvcmQgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBudW1iZXInIH07XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBmb3IgYXQgbGVhc3Qgb25lIGxldHRlclxyXG4gIGlmICghL1thLXpBLVpdLy50ZXN0KHBhc3N3b3JkKSkge1xyXG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIG1lc3NhZ2U6ICdQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGxldHRlcicgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IGlzVmFsaWQ6IHRydWUsIG1lc3NhZ2U6ICdQYXNzd29yZCBpcyBzdHJvbmcnIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSYXRlIGxpbWl0aW5nIGZvciBsb2dpbiBhdHRlbXB0c1xyXG4gKi9cclxuY2xhc3MgTG9naW5SYXRlTGltaXRlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmF0dGVtcHRzID0gbmV3IE1hcCgpOyAvLyBpZGVudGlmaWVyIC0+IHsgY291bnQsIHJlc2V0VGltZSB9XHJcbiAgICB0aGlzLm1heEF0dGVtcHRzID0gNTsgLy8gTWF4aW11bSBhdHRlbXB0c1xyXG4gICAgdGhpcy5sb2Nrb3V0RHVyYXRpb24gPSAxNSAqIDYwICogMTAwMDsgLy8gMTUgbWludXRlcyBpbiBtaWxsaXNlY29uZHNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY29yZCBhIGZhaWxlZCBsb2dpbiBhdHRlbXB0XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgLSBFbWFpbCBvciB1c2VybmFtZVxyXG4gICAqL1xyXG4gIHJlY29yZEZhaWxlZEF0dGVtcHQoaWRlbnRpZmllcikge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qga2V5ID0gaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuYXR0ZW1wdHMuZ2V0KGtleSkgfHwgeyBjb3VudDogMCwgcmVzZXRUaW1lOiBub3cgKyB0aGlzLmxvY2tvdXREdXJhdGlvbiB9O1xyXG5cclxuICAgIC8vIFJlc2V0IGlmIGxvY2tvdXQgcGVyaW9kIGhhcyBwYXNzZWRcclxuICAgIGlmIChub3cgPiByZWNvcmQucmVzZXRUaW1lKSB7XHJcbiAgICAgIHJlY29yZC5jb3VudCA9IDA7XHJcbiAgICAgIHJlY29yZC5yZXNldFRpbWUgPSBub3cgKyB0aGlzLmxvY2tvdXREdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZWNvcmQuY291bnQrKztcclxuICAgIHRoaXMuYXR0ZW1wdHMuc2V0KGtleSwgcmVjb3JkKTtcclxuXHJcbiAgICAvLyBQZXJzaXN0IHRvIGxvY2FsU3RvcmFnZVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYXR0ZW1wdHNEYXRhID0ge307XHJcbiAgICAgIHRoaXMuYXR0ZW1wdHMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGF0dGVtcHRzRGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbG9naW5fYXR0ZW1wdHMnLCBKU09OLnN0cmluZ2lmeShhdHRlbXB0c0RhdGEpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBsb2dpbiBhdHRlbXB0czonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBmYWlsZWQgYXR0ZW1wdHMgZm9yIGFuIGlkZW50aWZpZXIgKG9uIHN1Y2Nlc3NmdWwgbG9naW4pXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgLSBFbWFpbCBvciB1c2VybmFtZVxyXG4gICAqL1xyXG4gIGNsZWFyQXR0ZW1wdHMoaWRlbnRpZmllcikge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qga2V5ID0gaWRlbnRpZmllci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdGhpcy5hdHRlbXB0cy5kZWxldGUoa2V5KTtcclxuXHJcbiAgICAvLyBVcGRhdGUgbG9jYWxTdG9yYWdlXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBhdHRlbXB0c0RhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdsb2dpbl9hdHRlbXB0cycpIHx8ICd7fScpO1xyXG4gICAgICBkZWxldGUgYXR0ZW1wdHNEYXRhW2tleV07XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsb2dpbl9hdHRlbXB0cycsIEpTT04uc3RyaW5naWZ5KGF0dGVtcHRzRGF0YSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgbG9naW4gYXR0ZW1wdHM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgaWRlbnRpZmllciBpcyByYXRlIGxpbWl0ZWRcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciAtIEVtYWlsIG9yIHVzZXJuYW1lXHJcbiAgICogQHJldHVybnMge09iamVjdH0geyBpc0xpbWl0ZWQ6IGJvb2xlYW4sIHJlbWFpbmluZ1RpbWU6IG51bWJlciAobXMpLCBhdHRlbXB0c0xlZnQ6IG51bWJlciB9XHJcbiAgICovXHJcbiAgaXNSYXRlTGltaXRlZChpZGVudGlmaWVyKSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIHsgaXNMaW1pdGVkOiBmYWxzZSwgcmVtYWluaW5nVGltZTogMCwgYXR0ZW1wdHNMZWZ0OiB0aGlzLm1heEF0dGVtcHRzIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9hZCBmcm9tIGxvY2FsU3RvcmFnZVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYXR0ZW1wdHNEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbG9naW5fYXR0ZW1wdHMnKSB8fCAne30nKTtcclxuICAgICAgdGhpcy5hdHRlbXB0cy5jbGVhcigpO1xyXG4gICAgICBPYmplY3QuZW50cmllcyhhdHRlbXB0c0RhdGEpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdHMuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIC8vIElnbm9yZSBlcnJvcnNcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBrZXkgPSBpZGVudGlmaWVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCByZWNvcmQgPSB0aGlzLmF0dGVtcHRzLmdldChrZXkpO1xyXG5cclxuICAgIGlmICghcmVjb3JkKSB7XHJcbiAgICAgIHJldHVybiB7IGlzTGltaXRlZDogZmFsc2UsIHJlbWFpbmluZ1RpbWU6IDAsIGF0dGVtcHRzTGVmdDogdGhpcy5tYXhBdHRlbXB0cyB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcblxyXG4gICAgLy8gUmVzZXQgaWYgbG9ja291dCBwZXJpb2QgaGFzIHBhc3NlZFxyXG4gICAgaWYgKG5vdyA+IHJlY29yZC5yZXNldFRpbWUpIHtcclxuICAgICAgdGhpcy5hdHRlbXB0cy5kZWxldGUoa2V5KTtcclxuICAgICAgcmV0dXJuIHsgaXNMaW1pdGVkOiBmYWxzZSwgcmVtYWluaW5nVGltZTogMCwgYXR0ZW1wdHNMZWZ0OiB0aGlzLm1heEF0dGVtcHRzIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gTWF0aC5tYXgoMCwgdGhpcy5tYXhBdHRlbXB0cyAtIHJlY29yZC5jb3VudCk7XHJcbiAgICBjb25zdCBpc0xpbWl0ZWQgPSByZWNvcmQuY291bnQgPj0gdGhpcy5tYXhBdHRlbXB0cztcclxuICAgIGNvbnN0IHJlbWFpbmluZ1RpbWUgPSBNYXRoLm1heCgwLCByZWNvcmQucmVzZXRUaW1lIC0gbm93KTtcclxuXHJcbiAgICByZXR1cm4geyBpc0xpbWl0ZWQsIHJlbWFpbmluZ1RpbWUsIGF0dGVtcHRzTGVmdCB9O1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgbG9naW5SYXRlTGltaXRlciA9IG5ldyBMb2dpblJhdGVMaW1pdGVyKCk7XHJcblxyXG4iXSwibmFtZXMiOlsiaGFzaFBhc3N3b3JkIiwiaXNTZWN1cmVIYXNoIiwibG9naW5SYXRlTGltaXRlciIsInZhbGlkYXRlUGFzc3dvcmRTdHJlbmd0aCIsInZlcmlmeVBhc3N3b3JkIiwicGFzc3dvcmQiLCJFcnJvciIsInNhbHQiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJVaW50OEFycmF5Iiwic2FsdEhleCIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsInBhc3N3b3JkRGF0YSIsImVuY29kZSIsImtleU1hdGVyaWFsIiwic3VidGxlIiwiaW1wb3J0S2V5IiwibmFtZSIsImRlcml2ZWRCaXRzIiwiZGVyaXZlQml0cyIsIml0ZXJhdGlvbnMiLCJoYXNoIiwiaGFzaEFycmF5IiwiaGFzaEhleCIsImluY2x1ZGVzIiwic3RvcmVkSGFzaCIsInNwbGl0IiwibWF0Y2giLCJieXRlIiwicGFyc2VJbnQiLCJlcnJvciIsImNvbnNvbGUiLCJwYXJ0cyIsImxlbmd0aCIsImlzVmFsaWQiLCJtZXNzYWdlIiwidGVzdCIsIkxvZ2luUmF0ZUxpbWl0ZXIiLCJhdHRlbXB0cyIsIk1hcCIsIm1heEF0dGVtcHRzIiwibG9ja291dER1cmF0aW9uIiwicmVjb3JkRmFpbGVkQXR0ZW1wdCIsImlkZW50aWZpZXIiLCJ3aW5kb3ciLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsIm5vdyIsIkRhdGUiLCJyZWNvcmQiLCJnZXQiLCJjb3VudCIsInJlc2V0VGltZSIsInNldCIsImF0dGVtcHRzRGF0YSIsImZvckVhY2giLCJ2YWx1ZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiY2xlYXJBdHRlbXB0cyIsImRlbGV0ZSIsInBhcnNlIiwiZ2V0SXRlbSIsImlzUmF0ZUxpbWl0ZWQiLCJpc0xpbWl0ZWQiLCJyZW1haW5pbmdUaW1lIiwiYXR0ZW1wdHNMZWZ0IiwiY2xlYXIiLCJPYmplY3QiLCJlbnRyaWVzIiwiTWF0aCIsIm1heCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEOzs7O0NBSUM7Ozs7Ozs7Ozs7O1FBQ3FCQTtlQUFBQTs7UUFnSE5DO2VBQUFBOztRQWtKSEM7ZUFBQUE7O1FBcklHQztlQUFBQTs7UUE5RU1DO2VBQUFBOzs7QUEvQ2YsZUFBZUosYUFBYUssUUFBUTtJQUN6QyxJQUFJLENBQUNBLFlBQVksT0FBT0EsYUFBYSxVQUFVO1FBQzdDLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLHlCQUF5QjtJQUN6QixNQUFNQyxPQUFPQyxPQUFPQyxlQUFlLENBQUMsSUFBSUMsV0FBVztJQUNuRCxNQUFNQyxVQUFVQyxNQUFNQyxJQUFJLENBQUNOLE1BQU1PLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQztJQUVoRixrQ0FBa0M7SUFDbEMsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixNQUFNQyxlQUFlRixRQUFRRyxNQUFNLENBQUNqQjtJQUVwQyxrRUFBa0U7SUFDbEUsTUFBTWtCLGNBQWMsTUFBTWYsT0FBT2dCLE1BQU0sQ0FBQ0MsU0FBUyxDQUMvQyxPQUNBSixjQUNBO1FBQUVLLE1BQU07SUFBUyxHQUNqQixPQUNBO1FBQUM7S0FBYTtJQUdoQixNQUFNQyxjQUFjLE1BQU1uQixPQUFPZ0IsTUFBTSxDQUFDSSxVQUFVLENBQ2hEO1FBQ0VGLE1BQU07UUFDTm5CLE1BQU1BO1FBQ05zQixZQUFZO1FBQ1pDLE1BQU07SUFDUixHQUNBUCxhQUNBLElBQUksc0JBQXNCOztJQUc1Qix3QkFBd0I7SUFDeEIsTUFBTVEsWUFBWW5CLE1BQU1DLElBQUksQ0FBQyxJQUFJSCxXQUFXaUI7SUFDNUMsTUFBTUssVUFBVUQsVUFBVWpCLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQztJQUV6RSxzQ0FBc0M7SUFDdEMsT0FBTyxHQUFHUCxRQUFRLENBQUMsRUFBRXFCLFNBQVM7QUFDaEM7QUFRTyxlQUFlNUIsZUFBZUMsUUFBUSxFQUFFeUIsSUFBSTtJQUNqRCxJQUFJLENBQUN6QixZQUFZLENBQUN5QixNQUFNO1FBQ3RCLE9BQU87SUFDVDtJQUVBLG9GQUFvRjtJQUNwRix3RkFBd0Y7SUFDeEYsSUFBSSxDQUFDQSxLQUFLRyxRQUFRLENBQUMsTUFBTTtRQUN2QixtREFBbUQ7UUFDbkQsT0FBTzVCLGFBQWF5QjtJQUN0QjtJQUVBLElBQUk7UUFDRiwyQ0FBMkM7UUFDM0MsTUFBTSxDQUFDbkIsU0FBU3VCLFdBQVcsR0FBR0osS0FBS0ssS0FBSyxDQUFDO1FBQ3pDLElBQUksQ0FBQ3hCLFdBQVcsQ0FBQ3VCLFlBQVk7WUFDM0IsT0FBTztRQUNUO1FBRUEsc0NBQXNDO1FBQ3RDLE1BQU0zQixPQUFPLElBQUlHLFdBQ2ZDLFFBQVF5QixLQUFLLENBQUMsV0FBV3RCLEdBQUcsQ0FBQ3VCLENBQUFBLE9BQVFDLFNBQVNELE1BQU07UUFHdEQsa0NBQWtDO1FBQ2xDLE1BQU1sQixVQUFVLElBQUlDO1FBQ3BCLE1BQU1DLGVBQWVGLFFBQVFHLE1BQU0sQ0FBQ2pCO1FBRXBDLE1BQU1rQixjQUFjLE1BQU1mLE9BQU9nQixNQUFNLENBQUNDLFNBQVMsQ0FDL0MsT0FDQUosY0FDQTtZQUFFSyxNQUFNO1FBQVMsR0FDakIsT0FDQTtZQUFDO1NBQWE7UUFHaEIsbUNBQW1DO1FBQ25DLE1BQU1DLGNBQWMsTUFBTW5CLE9BQU9nQixNQUFNLENBQUNJLFVBQVUsQ0FDaEQ7WUFDRUYsTUFBTTtZQUNObkIsTUFBTUE7WUFDTnNCLFlBQVk7WUFDWkMsTUFBTTtRQUNSLEdBQ0FQLGFBQ0E7UUFHRixpQkFBaUI7UUFDakIsTUFBTVEsWUFBWW5CLE1BQU1DLElBQUksQ0FBQyxJQUFJSCxXQUFXaUI7UUFDNUMsTUFBTUssVUFBVUQsVUFBVWpCLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU1DLElBQUksQ0FBQztRQUV6RSw0Q0FBNEM7UUFDNUMsT0FBT2MsWUFBWUU7SUFDckIsRUFBRSxPQUFPSyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE9BQU87SUFDVDtBQUNGO0FBT08sU0FBU3RDLGFBQWE2QixJQUFJO0lBQy9CLElBQUksQ0FBQ0EsUUFBUSxPQUFPQSxTQUFTLFVBQVU7UUFDckMsT0FBTztJQUNUO0lBQ0EsTUFBTVcsUUFBUVgsS0FBS0ssS0FBSyxDQUFDO0lBQ3pCLE9BQU9NLE1BQU1DLE1BQU0sS0FBSyxLQUFLRCxLQUFLLENBQUMsRUFBRSxDQUFDQyxNQUFNLEdBQUcsS0FBS0QsS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsTUFBTSxHQUFHO0FBQ3hFO0FBT08sU0FBU3ZDLHlCQUF5QkUsUUFBUTtJQUMvQyxJQUFJLENBQUNBLFVBQVU7UUFDYixPQUFPO1lBQUVzQyxTQUFTO1lBQU9DLFNBQVM7UUFBdUI7SUFDM0Q7SUFFQSxJQUFJdkMsU0FBU3FDLE1BQU0sR0FBRyxHQUFHO1FBQ3ZCLE9BQU87WUFBRUMsU0FBUztZQUFPQyxTQUFTO1FBQXlDO0lBQzdFO0lBRUEsSUFBSXZDLFNBQVNxQyxNQUFNLEdBQUcsS0FBSztRQUN6QixPQUFPO1lBQUVDLFNBQVM7WUFBT0MsU0FBUztRQUE0QztJQUNoRjtJQUVBLGdDQUFnQztJQUNoQyxJQUFJLENBQUMsS0FBS0MsSUFBSSxDQUFDeEMsV0FBVztRQUN4QixPQUFPO1lBQUVzQyxTQUFTO1lBQU9DLFNBQVM7UUFBNEM7SUFDaEY7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSSxDQUFDLFdBQVdDLElBQUksQ0FBQ3hDLFdBQVc7UUFDOUIsT0FBTztZQUFFc0MsU0FBUztZQUFPQyxTQUFTO1FBQTRDO0lBQ2hGO0lBRUEsT0FBTztRQUFFRCxTQUFTO1FBQU1DLFNBQVM7SUFBcUI7QUFDeEQ7QUFFQTs7Q0FFQyxHQUNELE1BQU1FO0lBQ0osYUFBYztRQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlDLE9BQU8scUNBQXFDO1FBQ2hFLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEdBQUcsbUJBQW1CO1FBQ3pDLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEtBQUssS0FBSyxNQUFNLDZCQUE2QjtJQUN0RTtJQUVBOzs7R0FHQyxHQUNEQyxvQkFBb0JDLFVBQVUsRUFBRTtRQUM5QixJQUFJLE9BQU9DLFdBQVcsYUFBYTtRQUVuQyxNQUFNQyxNQUFNRixXQUFXRyxXQUFXO1FBQ2xDLE1BQU1DLE1BQU1DLEtBQUtELEdBQUc7UUFDcEIsTUFBTUUsU0FBUyxJQUFJLENBQUNYLFFBQVEsQ0FBQ1ksR0FBRyxDQUFDTCxRQUFRO1lBQUVNLE9BQU87WUFBR0MsV0FBV0wsTUFBTSxJQUFJLENBQUNOLGVBQWU7UUFBQztRQUUzRixxQ0FBcUM7UUFDckMsSUFBSU0sTUFBTUUsT0FBT0csU0FBUyxFQUFFO1lBQzFCSCxPQUFPRSxLQUFLLEdBQUc7WUFDZkYsT0FBT0csU0FBUyxHQUFHTCxNQUFNLElBQUksQ0FBQ04sZUFBZTtRQUMvQztRQUVBUSxPQUFPRSxLQUFLO1FBQ1osSUFBSSxDQUFDYixRQUFRLENBQUNlLEdBQUcsQ0FBQ1IsS0FBS0k7UUFFdkIsMEJBQTBCO1FBQzFCLElBQUk7WUFDRixNQUFNSyxlQUFlLENBQUM7WUFDdEIsSUFBSSxDQUFDaEIsUUFBUSxDQUFDaUIsT0FBTyxDQUFDLENBQUNDLE9BQU9YO2dCQUM1QlMsWUFBWSxDQUFDVCxJQUFJLEdBQUdXO1lBQ3RCO1lBQ0FDLGFBQWFDLE9BQU8sQ0FBQyxrQkFBa0JDLEtBQUtDLFNBQVMsQ0FBQ047UUFDeEQsRUFBRSxPQUFPeEIsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUNoRDtJQUNGO0lBRUE7OztHQUdDLEdBQ0QrQixjQUFjbEIsVUFBVSxFQUFFO1FBQ3hCLElBQUksT0FBT0MsV0FBVyxhQUFhO1FBRW5DLE1BQU1DLE1BQU1GLFdBQVdHLFdBQVc7UUFDbEMsSUFBSSxDQUFDUixRQUFRLENBQUN3QixNQUFNLENBQUNqQjtRQUVyQixzQkFBc0I7UUFDdEIsSUFBSTtZQUNGLE1BQU1TLGVBQWVLLEtBQUtJLEtBQUssQ0FBQ04sYUFBYU8sT0FBTyxDQUFDLHFCQUFxQjtZQUMxRSxPQUFPVixZQUFZLENBQUNULElBQUk7WUFDeEJZLGFBQWFDLE9BQU8sQ0FBQyxrQkFBa0JDLEtBQUtDLFNBQVMsQ0FBQ047UUFDeEQsRUFBRSxPQUFPeEIsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsa0NBQWtDQTtRQUNsRDtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNEbUMsY0FBY3RCLFVBQVUsRUFBRTtRQUN4QixJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUNqQyxPQUFPO2dCQUFFc0IsV0FBVztnQkFBT0MsZUFBZTtnQkFBR0MsY0FBYyxJQUFJLENBQUM1QixXQUFXO1lBQUM7UUFDOUU7UUFFQSx5QkFBeUI7UUFDekIsSUFBSTtZQUNGLE1BQU1jLGVBQWVLLEtBQUtJLEtBQUssQ0FBQ04sYUFBYU8sT0FBTyxDQUFDLHFCQUFxQjtZQUMxRSxJQUFJLENBQUMxQixRQUFRLENBQUMrQixLQUFLO1lBQ25CQyxPQUFPQyxPQUFPLENBQUNqQixjQUFjQyxPQUFPLENBQUMsQ0FBQyxDQUFDVixLQUFLVyxNQUFNO2dCQUNoRCxJQUFJLENBQUNsQixRQUFRLENBQUNlLEdBQUcsQ0FBQ1IsS0FBS1c7WUFDekI7UUFDRixFQUFFLE9BQU8xQixPQUFPO1FBQ2QsZ0JBQWdCO1FBQ2xCO1FBRUEsTUFBTWUsTUFBTUYsV0FBV0csV0FBVztRQUNsQyxNQUFNRyxTQUFTLElBQUksQ0FBQ1gsUUFBUSxDQUFDWSxHQUFHLENBQUNMO1FBRWpDLElBQUksQ0FBQ0ksUUFBUTtZQUNYLE9BQU87Z0JBQUVpQixXQUFXO2dCQUFPQyxlQUFlO2dCQUFHQyxjQUFjLElBQUksQ0FBQzVCLFdBQVc7WUFBQztRQUM5RTtRQUVBLE1BQU1PLE1BQU1DLEtBQUtELEdBQUc7UUFFcEIscUNBQXFDO1FBQ3JDLElBQUlBLE1BQU1FLE9BQU9HLFNBQVMsRUFBRTtZQUMxQixJQUFJLENBQUNkLFFBQVEsQ0FBQ3dCLE1BQU0sQ0FBQ2pCO1lBQ3JCLE9BQU87Z0JBQUVxQixXQUFXO2dCQUFPQyxlQUFlO2dCQUFHQyxjQUFjLElBQUksQ0FBQzVCLFdBQVc7WUFBQztRQUM5RTtRQUVBLE1BQU00QixlQUFlSSxLQUFLQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUNqQyxXQUFXLEdBQUdTLE9BQU9FLEtBQUs7UUFDaEUsTUFBTWUsWUFBWWpCLE9BQU9FLEtBQUssSUFBSSxJQUFJLENBQUNYLFdBQVc7UUFDbEQsTUFBTTJCLGdCQUFnQkssS0FBS0MsR0FBRyxDQUFDLEdBQUd4QixPQUFPRyxTQUFTLEdBQUdMO1FBRXJELE9BQU87WUFBRW1CO1lBQVdDO1lBQWVDO1FBQWE7SUFDbEQ7QUFDRjtBQUdPLE1BQU0zRSxtQkFBbUIsSUFBSTRDIn0=